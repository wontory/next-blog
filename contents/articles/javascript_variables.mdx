---
title: 변수 다루기
description: 클린코드 자바스크립트(JavaScript)
category: JavaScript
image: https://img-c.udemycdn.com/course/480x270/4253080_1e23.jpg
date: 2024-02-09T00:00+0900
---

타인이 정의한 답을 의심한다. 배움에 열린 태도를 가진다. 직접 생각하고 고민한다.  
Clean Code JavaScript 시작.

[Poco Jang](https://github.com/pocojang)님의 [클린코드 자바스크립트(JavaScript)](https://www.udemy.com/course/clean-code-js/) 강의를 정리한 글입니다.

## var를 지양하자

`let`과 `const`는 **ES2015**에서 등장했다. 그 이전에는 `var` 키워드를 사용는 것이 변수를 생성할 수 있는 유일한 방법이었다.
그렇다면 `let`, `const`는 `var`와 어떻게 다르고 또 왜 도입되었을까?

`var`는 **함수 스코프**를 가지고, `let`과 `const`는 **블록 스코프**와 함께 **Temporal Dead Zone**을 가진다.
그래서 `var` 대신 `let`과 `const`를 사용하면 더 안전하게 코드를 작성할 수 있다.

지금부터 코드를 통해 `var`, `let`, `const` 세 키워드의 특징을 알아보자.

### var의 특징

```js
var name = '이름'
var name = '이름2'
var name = '이름3'
var name = '이름3'

console.log(name) // 이름3
```

위 코드에서는 `var` 키워드로 동일한 이름의 변수를 여러 번 선언 및 할당하고 있다. 그럼에도 오류가 발생하지 않고 있다.

`var`는 **중복선언**과 **재할당**이 가능하다. 이후에 `var`로 선언된 변수를 호출하면, **마지막으로 할당된 값이 반환**된다.

다음 코드도 살펴보자.

```js
console.log(name) // undefined

var name = '이름'
```

이번에는 변수를 선언하기도 전에 `console.log`로 `name`을 호출하고 있지만, 마찬가지로 오류없이 `undefined`를 반환하고 있는 모습이다.

여기에서 `var`를 `let`으로 변경하면 어떻게 될까?

### let의 특징

```js
let name = '이름'
let name = '이름2' // SyntaxError: Identifier 'name' has already been declared
let name = '이름3'
let name = '이름3'

console.log(name)
```

`var`와는 다르게 바로 오류를 띄워주고 있다. 이미 `name`이라는 변수를 선언했기 때문에 다시 쓸 수 없는 것이다.

이처럼 `let` 키워드로 변수를 선언하면, 동일한 이름으로 변수가 **중복선언되는 것을 방지**할 수 있다.
`var`에 비해 안전하게 코드를 작성할 수 있다.

### const의 특징

`const`도 `let`과 마찬가지로 중복선언에 대한 오류를 반환해준다. 그렇다면 `const`는 `let`과 어떤 차이점이 있는지 코드를 통해 살펴보자.

```js
let name
name = '이름'
console.log(name) // 이름
name = '이름2'
console.log(name) // 이름2

const fruit // SyntaxError: Missing initializer in const
fruit = '사과'

const color = 'red'
color = 'yellow'  // TypeError: Assignment to constant variable.
```

`const`는 **선언과 동시에 값을 할당**해줘야 한다. 그리고 `let`과는 다르게 **재할당이 불가능하다**는 특징이 있다.

지금까지 `var`, `let`, `const`의 특징을 살펴봤다. 다음은 이 셋의 스코프에 대해 알아보자.

## Function Scope & Block Scope

앞서 이야기했듯이 `var`, `let`, `const`는 스코프 차이를 가지고 있다. 코드를 통해 알아보자.

```js
var global = '전역'

if (global === '전역') {
  var global = '지역'

  console.log(global) // 지역
}

console.log(global) // 지역
```

`global` 변수의 값이 지역 공간에서만 바뀌기를 기대했지만 전역 공간에 있는 스코프까지 오염이 되었다. 왜 그런 것일까?  
바로 `var`가 `if` 안에 있기 때문이다. `var`는 함수 단위 스코프인데, `if`는 함수가 아니다.
그렇기 때문에 블록 단위 스코프로 바꾸지 않는 이상 이런 불안 요소를 계속 가지고 있게 된다.

그럼 `var`를 `let`으로 바꿔보자.

```js
let global = '전역'

if (global === '전역') {
  let global = '지역'

  console.log(global) // 지역
}

console.log(global) // 전역
```

매우 안전하다. 지역 변수로서의 역할을 블록 단위로 잘 수행하고 있다. 그리고 전역 공간에서는 그에 합당한 값을 보여주고 있다.

```js
let global = '전역'

{
  let global = '지역'

  console.log(global) // 지역
}

console.log(global) // 전역
```

`if`문을 제거해도 블록만으로 충분히 그 역할을 수행한다. 이렇게 블록 단위로 구분되는 `let`과 `const`를 사용하면 조금 더 안전하게 사람이 생각하듯이 코드를 작성하고, 그 코드에 대한 결과를 확인할 수가 있다.

### let < const

`let`보다 `const`를 사용하면 더욱 안전한 코드를 작성할 수 있다. 하지만 `const`를 사용하면 객체를 다루기 힘들지 않을까?

```js
const person = {
  name: 'jo',
  age: '23',
}

// Assignment to constant variable.
person = {
  name: 'wontory',
  age: '24',
}
```

앞서 `const`는 **재할당**이 불가능하다고 이야기했다. 그렇기 때문에 위와 같은 방법으로는 객체의 값을 변경할 수 없다.

```js
const person = {
  name: 'jo',
  age: '23',
}

person.name = 'wontory'
person.age = '25'

console.log(person) // { name: 'wontory', age: '25' }
```

객체의 값이 변경되었다. `person`을 재할당하지 않고 객체 내부의 값만 바꾼 것이기 때문에 정상적으로 작동한다.

배열의 경우에도 마찬가지다.

```js
const person = [
  {
    name: 'jo',
    age: '23',
  },
]

person.push({
  name: 'wontory',
  age: '25',
})

console.log(person) // [ { name: 'jo', age: '23' }, { name: 'wontory', age: '25' } ]
```

`const`는 **재할당**이 금지된다. 본연의 객체, 배열같은 레퍼런스 객체들을 조작할 때는 `const`를 사용해도 이상이 없다.

## 전역 공간 사용 최소화

전역 공간은 `window`와 `global`로 나뉜다. 브라우저 환경에서 돌아가는 경우에는 `window`가 최상위이고, NodeJS 환경에서는 `global`이 최상위가 된다.
`window`나 `global`같은 최상위 객체에는 굉장히 많은 것들이 담겨져 있는데, 그 중 대표적인 것이 자바스크립트 API 명세(`window.alert` 등)이다.

이러한 전역 공간의 사용을 최소화해야 하는 이유는 무엇일까?  
어디에서나 전역 공간에 접근할 수 있으면 좋은 것 아닌가?  
사실 이 부분은 규모있는 프로젝트를 진행해보기 전까지는 느끼기 힘들다.

지금부터 그 이유를 코드를 통해 살펴보자.

```html title="index.html"
<!doctype html>
<html lang="ko">
  <head>
    <title>Clean Code JavaScript</title>
  </head>
  <body>
    <script src="./index.js"></script>
  </body>
</html>
```

```js title="index.js"
var globalVar = 'global'

console.log(globalVar)
```

`globalVar`를 전역 변수로 선언하고, `console.log`로 호출하는 코드이다.
개발자 도구를 열어 전역 공간을 확인해보면 `window` 객체에 `globalVar`가 담겨있는 모습을 확인할 수 있다.
자바스크립트는 런타임 환경, 즉 이렇게 실행하는 환경도 변경할 수 있다. (Monkey patch)

![console.log(window)](https://i.imgur.com/NInovcz.png)

이렇게 작성된 코드는 다른 자바스크립트 파일에서도 `globalVar`에 접근할 수 있도록 만든다.

```js title="index2.js"
console.log(window.globalVar) // global
console.log(globalVar) // global
```

`index2.js`에서 `globalVar`를 별도로 선언하지 않았음에도 오류 없이 `index.js`의 `globalVar` 값을 출력하고 있다.
**파일을 분리했지만 스코프는 분리되지 않은 것이다.**

다른 예시들도 살펴보자.

```js {3}
const array = [10, 20, 30]

for (var index = 0; index < array.length; index++) {
  const element = array[index]
}
```

위 코드를 실행한 후 `window` 객체를 살펴보면 `index` 값이 남아있는 것을 확인할 수 있다.
앞서 이야기했던 `var`를 지양하자는 내용과 일부 겹치지만, `var`는 함수 스코프이기 때문에 반복문(블록)이 종료된 이후에도 전역 공간에 남아있게 되는 것이다.

다음 예시이다.

```js title="index.js"
var setTimeout = 'setTimeout'
```

```js title="index2.js"
setTimeout(() => {
  console.log('1초')
}, 1000)
```

`index.js`에서 `setTimeout`이라는 전역 변수를 선언했다. 하지만, `window`에는 이미 `setTimeout()`이라는 내장 함수가 있고, `index2.js`에서 이를 사용하고 있다.  
위 코드를 실행해보면 `setTimeout()`이 제대로 동작하지 않는다. 그럼에도 코드를 작성하는 단계에서는 어떠한 오류도 확인할 수 없다. 그 이유는 `setTimeout()`이 브라우저 Web API이기 때문이다.  
이렇게 더럽혀진 전역 공간은 심각한 오류를 불러일으키기도 한다.

**그렇다면 전역 공간이 오염되는 것을 어떻게 방지할 수 있을까?**

1. 전역 변수를 만들지 않는다.
2. 지역 변수만 만든다.
3. `window`, `global`에 접근 및 조작하지 않는다.
4. `const`와 `let`으로 변경한다.
5. IIFE(즉시 실행 함수), Module, Closure 등으로 스코프를 나눈다.

## 임시변수 제거하기

여기에서 임시변수는 특정 공간의 스코프 안에서 전역변수처럼 활용되는 변수를 말한다.

```js {2}
function getElements() {
  const result = {} // 임시변수

  result.title = document.querySelector('.title')
  result.text = document.querySelector('.text')
  result.value = document.querySelector('.value')

  return result
}
```

위 코드에서 `result`는 임시변수이다. 하지만 `const`로 선언했기 때문에 문제가 없어보일 수 있다.  
함수의 크기가 커지면 전역 공간처럼 될 수 있고, 그렇게 되면 이러한 임시 개체들이 위험한 요소가 될 수 있다.

이 함수는 생명주기가 간단하다. `querySelector`라는 웹 API를 통해서 DOM을 가져온 다음, 객체에 넣어 반환하는 것이 끝이다.

우리는 이 함수를 아래와 같이 수정할 수 있다.

```js
function getElements() {
  return {
    title: document.querySelector('.title'),
    text: document.querySelector('.text'),
    value: document.querySelector('.value'),
  }
}
```

위와 같이 수정함으로써 함수의 역할은 더 명확해졌고, 다른 개발자가 객체를 추가로 조작하기 애매해졌다.
`result`라는 임시변수가 생기는 순간 객체에 계속 접근할 수 있기 때문에 추가적인 조작을 하고싶은 유혹이 생길 수 있다.

다음은 Date Time을 다루는 유틸 함수이다.

```js
function getDateTime(targetDate) {
  let month = targetDate.getMonth()
  let day = targetDate.getDate()
  let hour = targetDate.Hours()

  month = month >= 10 ? month : '0' + month
  day = day >= 10 ? day : '0' + day
  hour = hour >= 10 ? hour : '0' + hour

  return { month, day, hour }
}
```

특정 `Date Object`를 받은 다음, 월, 날짜, 시간을 추출하고 추가적인 조작을 하고 있다.
만약 기획이나 마케팅 등으로 이 함수가 할 수 없는 기능이 필요해지는 경우, 우리는 **함수를 추가로 만들거나 기존 함수를 유지보수하며 수정하는** 두 가지 선택을 할 수 있다.

함수를 수정할 때는 꼼꼼하게 확인하지 않으면 그 함수를 사용하는 많은 곳에서 문제가 발생할 수 있기 때문에 우리는 항상 **바로 반환할 수 있는 형태**로 바꿔 주는 것이 좋다.

```js showLineNumbers
function getDateTime(targetDate) {
  const month = targetDate.getMonth()
  const day = targetDate.getDate()
  const hour = targetDate.Hours()

  return {
    month: month >= 10 ? month : '0' + month,
    day: day >= 10 ? day : '0' + day,
    hour: hour >= 10 ? hour : '0' + hour,
  }
}
```

`let`으로 선언했다는 것은 즉 수정해서 재할당한다는 약속을 의미할 수 있기 때문에 `const`로 변경하고, 바로 반환하는 형태로 수정해주었다.

이후에 추가적인 기능이 필요하다면, 위와 같이 추상화한 함수를 재활용할 수 있다.

```js showLineNumbers{13}
function getKrDateTime() {
  const currentDateTime = getDateTime(new Date())

  return {
    month: computedKrDate(currentDateTime.month) + '월',
    day: computedKrDate(currentDateTime.day) + '일',
    hour: computedKrDate(currentDateTime.hour) + '시',
  }
}
```

함수는 하나의 명확한 역할만 수행하면 된다. 하지만 임시변수라는 유혹에 빠지면 내부에서 임시변수만 계속 조작하게될 수 있다.

정리해보자면 임시변수를 제거해야하는 이유는 아래와 같다.

- 명령형으로 가득한 로직이 만들어진다.
- 어디서 어떻게 잘못되었는지 디버깅이 힘들다.
- 추가적인 코드를 작성하고 싶은 유혹에 빠지기 쉽다.

임시변수를 제거하기 위한 해결책은 어떤 것들이 있을까?

1. 함수를 작게 나누기
2. 바로 반환하기
3. 고차 함수(`map`, `filter`, `reduce` 등)
4. 선언형 프로그래밍 ⭢ React

## 호이스팅 주의하기

호이스팅이란 런타임 시기에서 선언과 할당이 분리되는 것을 뜻한다. `var`로 선언한 변수가 초기화가 제대로 이루어지지 않았을 때 `undefined`로 끌어올려질 수 있다.
즉, 선언부만 최상단으로 옮겨지는 것이다.

`let`과 `const`도 호이스팅의 영향을 받지만 **TDZ(Temporal Dead Zone)** 덕분에 비교적 안전하다.

아래의 코드를 보고 결과를 예측해보자.

```js showLineNumbers
var global = 0

function outer() {
  console.log(global)
  var global = 5

  function inner() {
    var global = 10

    console.log(global)
  }

  inner()

  global = 1

  console.log(global)
}

outer()
```

```bash title="Result"
undefined
10
1
```

여기에서 우리는 첫 번째 `console.log`에 주목할 필요가 있다.

왜 0도 5도 아닌 `undeinfed`가 출력되었을까?  
이는 호이스팅이 동작한 사례로, 사실 아래의 코드와 다름없는 코드이다.

```js showLineNumbers
var global = 0

function outer() {
  var global
  console.log(global) // undefined
  global = 5

  ...
}
```

변수의 선언과 할당이 일어나기 전에 메모리 공간을 미리 할당하기 때문에 이러한 현상이 발생한다.

다음의 예시도 살펴보자.

```js
var sum

console.log(typeof sum) // function

function sum() {
  return 1 + 2
}
```

`sum`이라는 변수를 선언하고, 바로 `console.log`를 통해 `sum`의 타입을 출력했다. 하지만 예상과는 다르게 `function`으로 출력되었다.
이유는 그 아래에 `sum` 함수 때문인데, 이를 통해 **함수도 결국 호이스팅된다**는 사실을 알 수 있다.

```js
var sum

console.log(sum()) // 10

function sum() {
  return 1 + 2
}

function sum() {
  return 1 + 2 + 3
}

function sum() {
  return 1 + 2 + 3 + 4
}
```

같은 이름의 함수를 여러 번 선언했지만 마지막으로 선언된 함수의 결과가 반환되는 것을 확인해 볼 수 있다.

이 또한 호이스팅의 사례로 다음과 같이 수정함으로써 해결할 수 있다.

```js title="Solution 1"
var sum = 99

console.log(sum) // 99

function sum() {
  return 1 + 2
}
```

```js title="Solution 2"
console.log(sum()) // Cannot access 'sum' before initialization

const sum = function () {
  return 1 + 2
}
```

1. 선언과 동시에 할당(초기화)한다.
2. 함수 표현식을 사용한다. (익명 함수를 만들고 변수에 할당)

이렇게 호이스팅은 프로그래밍에 안좋은 영향을 주기 때문에, `let`과 `const`를 사용하면 `var`에 비해 안전하게 코드를 작성할 수 있다.
